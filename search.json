[{"title":"生成函数笔记.md","path":"/2025/10/19/生成函数笔记-md/","content":"生成函数入门对于无穷数列 ，其生成函数 。记号 表示 项的系数，也即 。 那么，它就有好多性质。考虑这样一个问题：我们有 个背包，对于第 个背包，它有能够选若干数，而选 个数的方案数 。那么我们就可以为这个背包考虑其生成函数 。现在，我们要在这 个背包中选总共 个数。那么，答案就是 ，即将这些背包卷起来。 一些常用性质： ，因为 。 。 P1450 [HAOI2008] 硬币购物题目传送门 题目描述共有 种硬币。面值分别为 。 某人去商店买东西，去了 次，对于每次购买，他带了 枚 种硬币，想购买 的价值的东西。请问每次有多少种付款方法。 。 做法考虑第 个硬币的生成函数，。 那么，把这四个硬币的生成函数卷起来，答案即是 。 考虑后面那个求积是什么，其本质就是去掉了 的限制，也即 个物品的完全背包。 那么最后要做的就是算出前面的 ，直接暴力 算，然后和预处理的完全背包再卷一下即可。时间复杂度 。 代码： #include bits/stdc++.husing namespace std;const int N = 1e5 + 5; typedef long long ll;int n, c[5], d[N]; ll f[N];int main() { for(int i = 1; i = 4; i++) scanf(\"%d\", c[i]); scanf(\"%d\", n); f[0] = 1; for(int i = 1; i = 4; i++) for(int j = c[i]; j = N - 5; j++) f[j] += f[j-c[i]]; while(n--) { int s; for(int i = 1; i = 4; i++) scanf(\"%d\", d[i]); scanf(\"%d\", s); ll ans = 0; for(int i = 0; i (1 4); i++) { int cnt = 0; ll sum = 0; for(int j = 1; j = 4; j++) { if((i (j - 1)) 1) { cnt++, sum += c[j] * 1ll * (d[j] + 1); if(sum s) break; } } if(sum s) continue; ans += f[s-sum] * ((cnt 1) ? -1 : 1); } printf(\"%lld \", ans); } return 0;}"},{"title":"二项式反演","path":"/2024/04/13/算法笔记-二项式反演/","content":"二项式反演介绍设 为恰好使用 个元素满足某条件的方案数， 为 个元素中选 个满足某条件其余元素随意的方案数。 显然 。那么，若已知 ，需求 ，有如下反演公式： 证明 将 展开 交换求和顺序： 根据 可得： 发现 是一个二项式定理， 因此： 证毕。 两种常见形式 形式一：设 为恰好使用 个元素满足某条件的方案数， 为 个元素中选 个满足某条件的方案数。 形式二：设 为 个元素中恰好有 个满足条件的方案数， 为 个元素中有 个满足条件其余随意的方案数。 例题错排问题 给定 ，求长度为 的序列的错排数量。 设 为恰好有 个位置错开， 为至多有 个位置错开 容易发现 ，则运用形式一反演可得：。 预处理组合数，时间复杂度 。 P4859 已经没有什么好害怕的了 给定长度为 的两个序列 ，将 中的元素和 中的一一配对，求有多少种方案使得 ĵ 的对数比 的对数恰好多 组。 设 表示 的对数，因此 ，解得 。 先将 和 按升序排序。考虑 dp，设 表示 中小于 的元素个数， 表示 已经匹配好，有至少 个位置满足 的方案数。 考虑转移，可以从 转移；另一种是从 转移，因为 是升序的，所以第 位能选的方案数是 。 由于 中我们只考虑了 的位置，其他位置可以随便排，因此设 。 运用形式二反演可得：。答案即为 ，时间复杂度 。","tags":["算法笔记"]},{"title":"题解:P2231 跳蚤","path":"/2024/03/16/题解-P2231-跳蚤/","content":"题解：P2231 [HNOI2002] 跳蚤P2231 [HNOI2002] 跳蚤 - 洛谷 原问题等价于求解关于 的不定方程 的解个数。 很显然, 原方程当且仅当 时有解。 正难则反,即用 减去 的情况。 设 则 。考虑到 ，有 种 。 所以，对于 的因数 ，共有 种方式使得答案有解。 考虑能不能只考虑 的质因数的贡献。如果直接把 的质因数的贡献加起来显然可能出现同一个质因数被算进其他质因数的贡献里。考虑容斥原理。 令全集 为 的所有质因数，则 。 直接 dfs 或者 状压 即可，最终答案为 。 注意到 即 中最多含有 个元素。因此容斥时间复杂度 但考虑到需要分解质因数，因此总复杂度 。 给出关键代码: for(ll mask = 1; mask (1 k); mask++) { ll sum = 1; int cnt = 0; for(int i = 1; i = k; i++) if(mask (1ll (i - 1))) cnt++, sum *= prime[i]; if(cnt % 2 == 0) ans -= qpow(m / sum, n); else ans += qpow(m / sum, n);}","tags":["题解"]},{"title":"线段树优化建图","path":"/2024/03/10/算法笔记-线段树优化建图/","content":"线段树优化建图三种操作: 从 到 建一条边 从 到 内的每一个点都建一条边 从 内的每一个点都向 建一条边 点数,操作数 显然, 的暴力建边会 , 那么怎么优化? 看到区间显然会想到线段树 考虑到一个区间在线段树上最多可以表示成 个节点, 可以考虑建边时直接指向线段树上的节点。 建树 建立两棵线段树: 一棵入树负责管理边的终点 一棵出树负责管理边的起点 因为两棵树的叶子节点本是同一个节点,因此用边权为0的双向边连接。 入树建树时因从父亲向儿子连边权为0的有向边,出树则应从儿子连向父亲。 算法流程 考虑第二个操作:从 到 内的每一个点都建一条边。很显然,应从出树的叶子节点向入树的区间连边。 例:从 到 连边,就在线段树区间修改的递归途中边递归边连边 考虑第三个操作:从 内的每一个点都向 建一条边。跟操作二一样,应从出树的区间向入树的叶子节点连边。 例:从 到 连边。 这样,我们就解决了建图。可以证明，这样连边建出的图和原来的图没有区别。注意，两棵线段树叶子节点之间的边以及从父亲到儿子、从儿子到父亲的边是必不可少的。建图时间复杂度 。 模板题CF786B Legacy 建图直接运用上述算法即可。 跑最短路时注意以下几点: 需要记录每个原始节点在两棵线段树中分别的位置,以供进行2,3操作 进行操作时需要在记录的线段树上的位置上操作 连边时注意方向以及叶子节点之间的边、父亲到儿子、儿子到父亲的边,这样跑出来的最短路才是对的 代码见 线段树优化建图模板","tags":["算法笔记"]},{"title":"Hello World","path":"/2024/03/02/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new My New Post More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment"}]