[{"title":"20240310-[算法笔记]线段树优化建图","path":"/2024/03/10/20240310-算法笔记-线段树优化建图/","content":"线段树优化建图三种操作: 从 $u$ 到 $v$ 建一条边 从 $u$ 到 $[l,r]$ 内的每一个点都建一条边 从 $[l,r]$ 内的每一个点都向 $v$ 建一条边 点数,操作数 $\\leq 10^5$ 显然, $O(n^2)$的暴力建边会 $TLE$, 那么怎么优化? 看到区间显然会想到线段树 考虑到一个区间在线段树上最多可以表示成 $O(\\log{n})$ 个节点, 可以考虑建边时直接指向线段树上的节点。 建树 建立两棵线段树: 一棵入树负责管理边的终点 一棵出树负责管理边的起点 因为两棵树的叶子节点本是同一个节点,因此用边权为0的双向边连接。 入树建树时因从父亲向儿子连边权为0的有向边,出树则应从儿子连向父亲。 算法流程 考虑第二个操作:从 $u$ 到 $[l,r]$ 内的每一个点都建一条边。很显然,应从出树的叶子节点向入树的区间连边。 例:从 $6$ 到 $[4,7]$ 连边,就在线段树区间修改的递归途中边递归边连边 考虑第三个操作:从 $[l,r]$ 内的每一个点都向 $v$ 建一条边。跟操作二一样,应从出树的区间向入树的叶子节点连边。 例:从 $4$ 到 $[2,5]$ 连边。 这样,我们就解决了建图。可以证明，这样连边建出的图和原来的图没有区别。注意，两棵线段树叶子节点之间的边以及从父亲到儿子、从儿子到父亲的边是必不可少的。建图时间复杂度 $O(n\\log{n})$。 模板题CF786B Legacy 建图直接运用上述算法即可。 跑最短路时注意以下几点: 需要记录每个原始节点在两棵线段树中分别的位置,以供进行2,3操作 进行操作时需要在记录的线段树上的位置上操作 连边时注意方向以及叶子节点之间的边、父亲到儿子、儿子到父亲的边,这样跑出来的最短路才是对的 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5;typedef long long ll;int n, m, st, pos_in[N], pos_out[N];struct Edge &#123; int v; ll w; bool operator &lt; (const Edge &amp;r) const &#123; return r.w &lt; w; &#125;&#125;; vector &lt;Edge&gt; e[N*4*2];#define lc 2*p#define rc 2*p+1#define MID (tr[p].l+tr[p].r)/2struct Node &#123; int l, r; &#125; tr[N*4*2];void Build_in(int p, int bL, int bR) &#123; // 建入树 tr[p].l = bL, tr[p].r = bR; if(bL == bR) &#123; pos_in[bL] = p; // 记录每个叶子节点(相当于图上的节点)在线段树中的下标 return ; &#125; int mid = MID; Build_in(lc, bL, mid); Build_in(rc, mid + 1, bR); // 向孩子连边 e[p].push_back(&#123;lc, 0&#125;); e[p].push_back(&#123;rc, 0&#125;);&#125;void Build_out(int p, int bL, int bR) &#123; // 建出树 tr[p].l = bL - n, tr[p].r = bR - n; // 注意下标 if(bL == bR) &#123; // 向入树的叶子节点连双向边 e[pos_in[bL-n]].push_back(&#123;p, 0&#125;); e[p].push_back(&#123;pos_in[bL-n], 0&#125;); pos_out[bL-n] = p; // 记录每个叶子节点(相当于图上的节点)在线段树中的下标 return ; &#125; int mid = MID + n; Build_out(lc, bL, mid); Build_out(rc, mid + 1, bR); // 孩子向父亲连边 e[lc].push_back(&#123;p, 0&#125;); e[rc].push_back(&#123;p, 0&#125;);&#125;void Update_in(int p, int qL, int qR, int i, ll d) &#123; // 操作二,从出树叶子节点向入树区间连边 if(qL &lt;= tr[p].l &amp;&amp; tr[p].r &lt;= qR) &#123; e[i].push_back(&#123;p, d&#125;); return ; &#125; int mid = MID; if(qR &lt;= mid) Update_in(lc, qL, qR, i, d); else if(qL &gt; mid) Update_in(rc, qL, qR, i, d); else &#123; Update_in(lc, qL, qR, i, d); Update_in(rc, qL, qR, i, d); &#125;&#125;void Update_out(int p, int qL, int qR, int i, ll d) &#123; // 操作三,从出树区间向入树叶子节点连边 if(qL &lt;= tr[p].l &amp;&amp; tr[p].r &lt;= qR) &#123; e[p].push_back(&#123;i, d&#125;); return ; &#125; int mid = MID; if(qR &lt;= mid) Update_out(lc, qL, qR, i, d); else if(qL &gt; mid) Update_out(rc, qL, qR, i, d); else &#123; Update_out(lc, qL, qR, i, d); Update_out(rc, qL, qR, i, d); &#125;&#125;bool vis[N*4*2]; ll dis[N*4*2]; priority_queue &lt;Edge&gt; q;void dijkstra(int s) &#123; memset(dis, 0x3f, sizeof(dis)); dis[pos_in[s]] = 0; q.push(&#123;pos_in[s], 0&#125;); // 注意是从线段树中的下标开始 // 其实pos_in[s]和pos_out[s]有边相连,无所谓从哪个开始 while(!q.empty()) &#123; int u = q.top().v; q.pop(); if(vis[u]) continue ; vis[u] = true; for(auto x : e[u]) &#123; int v = x.v; ll w = x.w; if(dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; q.push(&#123;v, dis[v]&#125;); &#125; &#125; &#125;&#125;int main() &#123; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;st); Build_in(2, 1, n); Build_out(3, n + 1, 2 * n); // 小细节,两棵线段树根节点分别开在2,3避免混乱 while(m--) &#123; int op; scanf(&quot;%d&quot;, &amp;op); if(op == 1) &#123; int u, v; ll w; scanf(&quot;%d%d%lld&quot;, &amp;u, &amp;v, &amp;w); e[pos_out[u]].push_back(&#123;pos_in[v], w&#125;); &#125; else if(op == 2) &#123; int u, l, r; ll w; scanf(&quot;%d%d%d%lld&quot;, &amp;u, &amp;l, &amp;r, &amp;w); Update_in(2, l, r, pos_out[u], w); // 注意是从 pos_out 连边 &#125; else &#123; int v, l, r; ll w; scanf(&quot;%d%d%d%lld&quot;, &amp;v, &amp;l, &amp;r, &amp;w); Update_out(3, l, r, pos_in[v], w); // 注意是连向 pos_in &#125; &#125; dijkstra(st); for(int i = 1; i &lt;= n; i++) if(dis[pos_in[i]] == 0x3f3f3f3f3f3f3f3f) printf(&quot;-1 &quot;); else printf(&quot;%lld &quot;, dis[pos_in[i]]); return 0;&#125;"},{"title":"20230303鲜花","path":"/2024/03/03/20230303鲜花/","content":"前两天考了两天的胜铉模拟，感觉要了。怎么办。我只会打暴力，还打错了。两试共六题一道都不会。感觉你们都能ak胜铉。不过没事，自信即巅峰！昨晚写一篇游记直接干了2h，我没实力。 少年站在篮球架下，看着操场上的两个人跑着笑着，打着闹着。学校十分寂静，夜幕即将降临，天空中闪耀着零星的星星。挥洒着，就这样走了，前往「远方」，前往深不可测。看着「浅谈」，不禁有些感动，看着「空白」的草稿纸，不禁有些迷茫，“你不会！”，不禁有些慌张。拿起笔，奋笔疾书。半个小时，强拉着的心绷不住了。睡大觉。又看见篮筐底下的少年，只不过不是「他」。一天还没过完，就已经过的这么快了。满天星斗。跑向他。激动。累得趴下。拿起笔。开始敲击键盘。结束。离开。 怪谈：数据结构是神仙的，数论是难的，组合是晕的，而信息物理题是一点也听不懂的。","tags":["鲜花"]},{"title":"Hello World","path":"/2024/03/02/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]